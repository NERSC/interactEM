// This file is auto-generated by @hey-api/openapi-ts

import { type Client, type Options as Options2, type TDataShape, urlSearchParamsBodySerializer } from './client';
import { client } from './client.gen';
import type { AgentsLaunchAgentData, AgentsLaunchAgentErrors, AgentsLaunchAgentResponses, DeploymentsCreateOperatorEventData, DeploymentsCreateOperatorEventErrors, DeploymentsCreateOperatorEventResponses, DeploymentsCreatePipelineDeploymentData, DeploymentsCreatePipelineDeploymentErrors, DeploymentsCreatePipelineDeploymentResponses, DeploymentsListPipelineDeploymentsData, DeploymentsListPipelineDeploymentsErrors, DeploymentsListPipelineDeploymentsResponses, DeploymentsReadPipelineDeploymentData, DeploymentsReadPipelineDeploymentErrors, DeploymentsReadPipelineDeploymentResponses, DeploymentsUpdatePipelineDeploymentData, DeploymentsUpdatePipelineDeploymentErrors, DeploymentsUpdatePipelineDeploymentResponses, LoginLoginAccessTokenData, LoginLoginAccessTokenErrors, LoginLoginAccessTokenResponses, LoginLoginWithExternalTokenData, LoginLoginWithExternalTokenResponses, LoginTestTokenData, LoginTestTokenResponses, OperatorsReadOperatorsData, OperatorsReadOperatorsErrors, OperatorsReadOperatorsResponses, PipelinesAddPipelineRevisionData, PipelinesAddPipelineRevisionErrors, PipelinesAddPipelineRevisionResponses, PipelinesCreatePipelineData, PipelinesCreatePipelineErrors, PipelinesCreatePipelineResponses, PipelinesDeletePipelineData, PipelinesDeletePipelineErrors, PipelinesDeletePipelineResponses, PipelinesDuplicatePipelineData, PipelinesDuplicatePipelineErrors, PipelinesDuplicatePipelineResponses, PipelinesListPipelineDeploymentsData, PipelinesListPipelineDeploymentsErrors, PipelinesListPipelineDeploymentsResponses, PipelinesListPipelineRevisionDeploymentsData, PipelinesListPipelineRevisionDeploymentsErrors, PipelinesListPipelineRevisionDeploymentsResponses, PipelinesListPipelineRevisionsData, PipelinesListPipelineRevisionsErrors, PipelinesListPipelineRevisionsResponses, PipelinesReadPipelineData, PipelinesReadPipelineErrors, PipelinesReadPipelineResponses, PipelinesReadPipelineRevisionData, PipelinesReadPipelineRevisionErrors, PipelinesReadPipelineRevisionResponses, PipelinesReadPipelinesData, PipelinesReadPipelinesErrors, PipelinesReadPipelinesResponses, PipelinesUpdatePipelineData, PipelinesUpdatePipelineErrors, PipelinesUpdatePipelineResponses, PipelinesUpdatePipelineRevisionData, PipelinesUpdatePipelineRevisionErrors, PipelinesUpdatePipelineRevisionPositionsData, PipelinesUpdatePipelineRevisionPositionsErrors, PipelinesUpdatePipelineRevisionPositionsResponses, PipelinesUpdatePipelineRevisionResponses, UsersCreateUserData, UsersCreateUserErrors, UsersCreateUserResponses, UsersDeleteUserData, UsersDeleteUserErrors, UsersDeleteUserMeData, UsersDeleteUserMeResponses, UsersDeleteUserResponses, UsersReadUserByIdData, UsersReadUserByIdErrors, UsersReadUserByIdResponses, UsersReadUserMeData, UsersReadUserMeResponses, UsersReadUsersData, UsersReadUsersErrors, UsersReadUsersResponses, UsersUpdatePasswordMeData, UsersUpdatePasswordMeErrors, UsersUpdatePasswordMeResponses, UsersUpdateUserData, UsersUpdateUserErrors, UsersUpdateUserMeData, UsersUpdateUserMeErrors, UsersUpdateUserMeResponses, UsersUpdateUserResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Login Access Token
 *
 * OAuth2 compatible token login, get an access token for future requests
 */
export const loginLoginAccessToken = <ThrowOnError extends boolean = false>(options: Options<LoginLoginAccessTokenData, ThrowOnError>) => (options.client ?? client).post<LoginLoginAccessTokenResponses, LoginLoginAccessTokenErrors, ThrowOnError>({
    ...urlSearchParamsBodySerializer,
    responseType: 'json',
    url: '/api/v1/login/access-token',
    ...options,
    headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        ...options.headers
    }
});

/**
 * Login With External Token
 *
 * Login with an external token (e.g., distiller)
 */
export const loginLoginWithExternalToken = <ThrowOnError extends boolean = false>(options?: Options<LoginLoginWithExternalTokenData, ThrowOnError>) => (options?.client ?? client).post<LoginLoginWithExternalTokenResponses, unknown, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/login/external-token',
    ...options
});

/**
 * Test Token
 *
 * Test access token
 */
export const loginTestToken = <ThrowOnError extends boolean = false>(options?: Options<LoginTestTokenData, ThrowOnError>) => (options?.client ?? client).post<LoginTestTokenResponses, unknown, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/login/test-token',
    ...options
});

/**
 * Read Users
 *
 * Retrieve users.
 */
export const usersReadUsers = <ThrowOnError extends boolean = false>(options?: Options<UsersReadUsersData, ThrowOnError>) => (options?.client ?? client).get<UsersReadUsersResponses, UsersReadUsersErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/users/',
    ...options
});

/**
 * Create User
 *
 * Create new user.
 */
export const usersCreateUser = <ThrowOnError extends boolean = false>(options: Options<UsersCreateUserData, ThrowOnError>) => (options.client ?? client).post<UsersCreateUserResponses, UsersCreateUserErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/users/',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete User Me
 *
 * Delete own user.
 */
export const usersDeleteUserMe = <ThrowOnError extends boolean = false>(options?: Options<UsersDeleteUserMeData, ThrowOnError>) => (options?.client ?? client).delete<UsersDeleteUserMeResponses, unknown, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/users/me',
    ...options
});

/**
 * Read User Me
 *
 * Get current user.
 */
export const usersReadUserMe = <ThrowOnError extends boolean = false>(options?: Options<UsersReadUserMeData, ThrowOnError>) => (options?.client ?? client).get<UsersReadUserMeResponses, unknown, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/users/me',
    ...options
});

/**
 * Update User Me
 *
 * Update own user.
 */
export const usersUpdateUserMe = <ThrowOnError extends boolean = false>(options: Options<UsersUpdateUserMeData, ThrowOnError>) => (options.client ?? client).patch<UsersUpdateUserMeResponses, UsersUpdateUserMeErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/users/me',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Update Password Me
 *
 * Update own password.
 */
export const usersUpdatePasswordMe = <ThrowOnError extends boolean = false>(options: Options<UsersUpdatePasswordMeData, ThrowOnError>) => (options.client ?? client).patch<UsersUpdatePasswordMeResponses, UsersUpdatePasswordMeErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/users/me/password',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete User
 *
 * Delete a user.
 */
export const usersDeleteUser = <ThrowOnError extends boolean = false>(options: Options<UsersDeleteUserData, ThrowOnError>) => (options.client ?? client).delete<UsersDeleteUserResponses, UsersDeleteUserErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/users/{user_id}',
    ...options
});

/**
 * Read User By Id
 *
 * Get a specific user by id.
 */
export const usersReadUserById = <ThrowOnError extends boolean = false>(options: Options<UsersReadUserByIdData, ThrowOnError>) => (options.client ?? client).get<UsersReadUserByIdResponses, UsersReadUserByIdErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/users/{user_id}',
    ...options
});

/**
 * Update User
 *
 * Update a user.
 */
export const usersUpdateUser = <ThrowOnError extends boolean = false>(options: Options<UsersUpdateUserData, ThrowOnError>) => (options.client ?? client).patch<UsersUpdateUserResponses, UsersUpdateUserErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/users/{user_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Read Pipelines
 *
 * Retrieve pipelines, ordered by last updated. Includes pipeline name.
 */
export const pipelinesReadPipelines = <ThrowOnError extends boolean = false>(options?: Options<PipelinesReadPipelinesData, ThrowOnError>) => (options?.client ?? client).get<PipelinesReadPipelinesResponses, PipelinesReadPipelinesErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/pipelines/',
    ...options
});

/**
 * Create Pipeline
 *
 * Create new pipeline.
 */
export const pipelinesCreatePipeline = <ThrowOnError extends boolean = false>(options: Options<PipelinesCreatePipelineData, ThrowOnError>) => (options.client ?? client).post<PipelinesCreatePipelineResponses, PipelinesCreatePipelineErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/pipelines/',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete Pipeline
 *
 * Delete an pipeline.
 */
export const pipelinesDeletePipeline = <ThrowOnError extends boolean = false>(options: Options<PipelinesDeletePipelineData, ThrowOnError>) => (options.client ?? client).delete<PipelinesDeletePipelineResponses, PipelinesDeletePipelineErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/pipelines/{id}',
    ...options
});

/**
 * Read Pipeline
 *
 * Get pipeline by ID.
 */
export const pipelinesReadPipeline = <ThrowOnError extends boolean = false>(options: Options<PipelinesReadPipelineData, ThrowOnError>) => (options.client ?? client).get<PipelinesReadPipelineResponses, PipelinesReadPipelineErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/pipelines/{id}',
    ...options
});

/**
 * Update Pipeline
 *
 * Update a pipeline's name.
 */
export const pipelinesUpdatePipeline = <ThrowOnError extends boolean = false>(options: Options<PipelinesUpdatePipelineData, ThrowOnError>) => (options.client ?? client).patch<PipelinesUpdatePipelineResponses, PipelinesUpdatePipelineErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/pipelines/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List Pipeline Revisions
 *
 * List revisions for a pipeline (paginated).
 */
export const pipelinesListPipelineRevisions = <ThrowOnError extends boolean = false>(options: Options<PipelinesListPipelineRevisionsData, ThrowOnError>) => (options.client ?? client).get<PipelinesListPipelineRevisionsResponses, PipelinesListPipelineRevisionsErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/pipelines/{id}/revisions',
    ...options
});

/**
 * Add Pipeline Revision
 *
 * Add a new revision to a pipeline.
 */
export const pipelinesAddPipelineRevision = <ThrowOnError extends boolean = false>(options: Options<PipelinesAddPipelineRevisionData, ThrowOnError>) => (options.client ?? client).post<PipelinesAddPipelineRevisionResponses, PipelinesAddPipelineRevisionErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/pipelines/{id}/revisions',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Read Pipeline Revision
 *
 * Get specific revision data for a pipeline.
 */
export const pipelinesReadPipelineRevision = <ThrowOnError extends boolean = false>(options: Options<PipelinesReadPipelineRevisionData, ThrowOnError>) => (options.client ?? client).get<PipelinesReadPipelineRevisionResponses, PipelinesReadPipelineRevisionErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/pipelines/{id}/revisions/{revision_id}',
    ...options
});

/**
 * Update Pipeline Revision
 *
 * Update a specific pipeline revision.
 */
export const pipelinesUpdatePipelineRevision = <ThrowOnError extends boolean = false>(options: Options<PipelinesUpdatePipelineRevisionData, ThrowOnError>) => (options.client ?? client).patch<PipelinesUpdatePipelineRevisionResponses, PipelinesUpdatePipelineRevisionErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/pipelines/{id}/revisions/{revision_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Update Pipeline Revision Positions
 *
 * Update operator positions for a specific pipeline revision.
 */
export const pipelinesUpdatePipelineRevisionPositions = <ThrowOnError extends boolean = false>(options: Options<PipelinesUpdatePipelineRevisionPositionsData, ThrowOnError>) => (options.client ?? client).patch<PipelinesUpdatePipelineRevisionPositionsResponses, PipelinesUpdatePipelineRevisionPositionsErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/pipelines/{id}/revisions/{revision_id}/positions',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Duplicate Pipeline
 *
 * Duplicate a pipeline with all its revisions.
 */
export const pipelinesDuplicatePipeline = <ThrowOnError extends boolean = false>(options: Options<PipelinesDuplicatePipelineData, ThrowOnError>) => (options.client ?? client).post<PipelinesDuplicatePipelineResponses, PipelinesDuplicatePipelineErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/pipelines/{id}/duplicate',
    ...options
});

/**
 * List Pipeline Deployments
 *
 * List deployments for a pipeline.
 */
export const pipelinesListPipelineDeployments = <ThrowOnError extends boolean = false>(options: Options<PipelinesListPipelineDeploymentsData, ThrowOnError>) => (options.client ?? client).get<PipelinesListPipelineDeploymentsResponses, PipelinesListPipelineDeploymentsErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/pipelines/{id}/deployments',
    ...options
});

/**
 * List Pipeline Revision Deployments
 *
 * List all deployments for a specific pipeline revision.
 */
export const pipelinesListPipelineRevisionDeployments = <ThrowOnError extends boolean = false>(options: Options<PipelinesListPipelineRevisionDeploymentsData, ThrowOnError>) => (options.client ?? client).get<PipelinesListPipelineRevisionDeploymentsResponses, PipelinesListPipelineRevisionDeploymentsErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/pipelines/{id}/revisions/{revision_id}/deployments',
    ...options
});

/**
 * List Pipeline Deployments
 *
 * Get all pipeline deployments accessible to the current user with pagination.
 * Optionally filter by state.
 */
export const deploymentsListPipelineDeployments = <ThrowOnError extends boolean = false>(options?: Options<DeploymentsListPipelineDeploymentsData, ThrowOnError>) => (options?.client ?? client).get<DeploymentsListPipelineDeploymentsResponses, DeploymentsListPipelineDeploymentsErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/deployments/',
    ...options
});

/**
 * Create Pipeline Deployment
 *
 * Create a new pipeline deployment and publish initialization event.
 * State transitions are managed by the orchestrator.
 */
export const deploymentsCreatePipelineDeployment = <ThrowOnError extends boolean = false>(options: Options<DeploymentsCreatePipelineDeploymentData, ThrowOnError>) => (options.client ?? client).post<DeploymentsCreatePipelineDeploymentResponses, DeploymentsCreatePipelineDeploymentErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/deployments/',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Read Pipeline Deployment
 *
 * Get pipeline deployment by ID.
 */
export const deploymentsReadPipelineDeployment = <ThrowOnError extends boolean = false>(options: Options<DeploymentsReadPipelineDeploymentData, ThrowOnError>) => (options.client ?? client).get<DeploymentsReadPipelineDeploymentResponses, DeploymentsReadPipelineDeploymentErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/deployments/{id}',
    ...options
});

/**
 * Update Pipeline Deployment
 *
 * Update a pipeline deployment state and publish events for the orchestrator.
 */
export const deploymentsUpdatePipelineDeployment = <ThrowOnError extends boolean = false>(options: Options<DeploymentsUpdatePipelineDeploymentData, ThrowOnError>) => (options.client ?? client).patch<DeploymentsUpdatePipelineDeploymentResponses, DeploymentsUpdatePipelineDeploymentErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/deployments/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Create Operator Event
 *
 * Publish an operator event for the specified deployment and operator.
 */
export const deploymentsCreateOperatorEvent = <ThrowOnError extends boolean = false>(options: Options<DeploymentsCreateOperatorEventData, ThrowOnError>) => (options.client ?? client).post<DeploymentsCreateOperatorEventResponses, DeploymentsCreateOperatorEventErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/deployments/{id}/operators/{canonical_operator_id}/events',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Read Operators
 *
 * Retrieve available operators. Use refresh=true to invalidate cache and fetch fresh data.
 */
export const operatorsReadOperators = <ThrowOnError extends boolean = false>(options?: Options<OperatorsReadOperatorsData, ThrowOnError>) => (options?.client ?? client).get<OperatorsReadOperatorsResponses, OperatorsReadOperatorsErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/operators/',
    ...options
});

/**
 * Launch Agent
 *
 * Launch an agent remotely.
 */
export const agentsLaunchAgent = <ThrowOnError extends boolean = false>(options: Options<AgentsLaunchAgentData, ThrowOnError>) => (options.client ?? client).post<AgentsLaunchAgentResponses, AgentsLaunchAgentErrors, ThrowOnError>({
    responseType: 'json',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/agents/launch',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});
