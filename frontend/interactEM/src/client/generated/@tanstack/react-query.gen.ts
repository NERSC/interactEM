// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';
import type { AxiosError } from 'axios';

import { client } from '../client.gen';
import { agentsLaunchAgent, deploymentsCreateOperatorEvent, deploymentsCreatePipelineDeployment, deploymentsListPipelineDeployments, deploymentsReadPipelineDeployment, deploymentsUpdatePipelineDeployment, loginLoginAccessToken, loginLoginWithExternalToken, loginTestToken, operatorsReadOperators, type Options, pipelinesAddPipelineRevision, pipelinesCreatePipeline, pipelinesDeletePipeline, pipelinesDuplicatePipeline, pipelinesListPipelineDeployments, pipelinesListPipelineRevisionDeployments, pipelinesListPipelineRevisions, pipelinesReadPipeline, pipelinesReadPipelineRevision, pipelinesReadPipelines, pipelinesUpdatePipeline, pipelinesUpdatePipelineRevision, pipelinesUpdatePipelineRevisionPositions, usersCreateUser, usersDeleteUser, usersDeleteUserMe, usersReadUserById, usersReadUserMe, usersReadUsers, usersUpdatePasswordMe, usersUpdateUser, usersUpdateUserMe } from '../sdk.gen';
import type { AgentsLaunchAgentData, AgentsLaunchAgentError, DeploymentsCreateOperatorEventData, DeploymentsCreateOperatorEventError, DeploymentsCreateOperatorEventResponse, DeploymentsCreatePipelineDeploymentData, DeploymentsCreatePipelineDeploymentError, DeploymentsCreatePipelineDeploymentResponse, DeploymentsListPipelineDeploymentsData, DeploymentsListPipelineDeploymentsError, DeploymentsListPipelineDeploymentsResponse, DeploymentsReadPipelineDeploymentData, DeploymentsReadPipelineDeploymentError, DeploymentsReadPipelineDeploymentResponse, DeploymentsUpdatePipelineDeploymentData, DeploymentsUpdatePipelineDeploymentError, DeploymentsUpdatePipelineDeploymentResponse, LoginLoginAccessTokenData, LoginLoginAccessTokenError, LoginLoginAccessTokenResponse, LoginLoginWithExternalTokenData, LoginLoginWithExternalTokenResponse, LoginTestTokenData, LoginTestTokenResponse, OperatorsReadOperatorsData, OperatorsReadOperatorsError, OperatorsReadOperatorsResponse, PipelinesAddPipelineRevisionData, PipelinesAddPipelineRevisionError, PipelinesAddPipelineRevisionResponse, PipelinesCreatePipelineData, PipelinesCreatePipelineError, PipelinesCreatePipelineResponse, PipelinesDeletePipelineData, PipelinesDeletePipelineError, PipelinesDeletePipelineResponse, PipelinesDuplicatePipelineData, PipelinesDuplicatePipelineError, PipelinesDuplicatePipelineResponse, PipelinesListPipelineDeploymentsData, PipelinesListPipelineDeploymentsError, PipelinesListPipelineDeploymentsResponse, PipelinesListPipelineRevisionDeploymentsData, PipelinesListPipelineRevisionDeploymentsError, PipelinesListPipelineRevisionDeploymentsResponse, PipelinesListPipelineRevisionsData, PipelinesListPipelineRevisionsError, PipelinesListPipelineRevisionsResponse, PipelinesReadPipelineData, PipelinesReadPipelineError, PipelinesReadPipelineResponse, PipelinesReadPipelineRevisionData, PipelinesReadPipelineRevisionError, PipelinesReadPipelineRevisionResponse, PipelinesReadPipelinesData, PipelinesReadPipelinesError, PipelinesReadPipelinesResponse, PipelinesUpdatePipelineData, PipelinesUpdatePipelineError, PipelinesUpdatePipelineResponse, PipelinesUpdatePipelineRevisionData, PipelinesUpdatePipelineRevisionError, PipelinesUpdatePipelineRevisionPositionsData, PipelinesUpdatePipelineRevisionPositionsError, PipelinesUpdatePipelineRevisionPositionsResponse, PipelinesUpdatePipelineRevisionResponse, UsersCreateUserData, UsersCreateUserError, UsersCreateUserResponse, UsersDeleteUserData, UsersDeleteUserError, UsersDeleteUserMeData, UsersDeleteUserMeResponse, UsersDeleteUserResponse, UsersReadUserByIdData, UsersReadUserByIdError, UsersReadUserByIdResponse, UsersReadUserMeData, UsersReadUserMeResponse, UsersReadUsersData, UsersReadUsersError, UsersReadUsersResponse, UsersUpdatePasswordMeData, UsersUpdatePasswordMeError, UsersUpdatePasswordMeResponse, UsersUpdateUserData, UsersUpdateUserError, UsersUpdateUserMeData, UsersUpdateUserMeError, UsersUpdateUserMeResponse, UsersUpdateUserResponse } from '../types.gen';

/**
 * Login Access Token
 *
 * OAuth2 compatible token login, get an access token for future requests
 */
export const loginLoginAccessTokenMutation = (options?: Partial<Options<LoginLoginAccessTokenData>>): UseMutationOptions<LoginLoginAccessTokenResponse, AxiosError<LoginLoginAccessTokenError>, Options<LoginLoginAccessTokenData>> => {
    const mutationOptions: UseMutationOptions<LoginLoginAccessTokenResponse, AxiosError<LoginLoginAccessTokenError>, Options<LoginLoginAccessTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await loginLoginAccessToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Login With External Token
 *
 * Login with an external token (e.g., distiller)
 */
export const loginLoginWithExternalTokenMutation = (options?: Partial<Options<LoginLoginWithExternalTokenData>>): UseMutationOptions<LoginLoginWithExternalTokenResponse, AxiosError<DefaultError>, Options<LoginLoginWithExternalTokenData>> => {
    const mutationOptions: UseMutationOptions<LoginLoginWithExternalTokenResponse, AxiosError<DefaultError>, Options<LoginLoginWithExternalTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await loginLoginWithExternalToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Test Token
 *
 * Test access token
 */
export const loginTestTokenMutation = (options?: Partial<Options<LoginTestTokenData>>): UseMutationOptions<LoginTestTokenResponse, AxiosError<DefaultError>, Options<LoginTestTokenData>> => {
    const mutationOptions: UseMutationOptions<LoginTestTokenResponse, AxiosError<DefaultError>, Options<LoginTestTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await loginTestToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseURL: options?.baseURL || (options?.client ?? client).getConfig().baseURL } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const usersReadUsersQueryKey = (options?: Options<UsersReadUsersData>) => createQueryKey('usersReadUsers', options);

/**
 * Read Users
 *
 * Retrieve users.
 */
export const usersReadUsersOptions = (options?: Options<UsersReadUsersData>) => queryOptions<UsersReadUsersResponse, AxiosError<UsersReadUsersError>, UsersReadUsersResponse, ReturnType<typeof usersReadUsersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await usersReadUsers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: usersReadUsersQueryKey(options)
});

/**
 * Create User
 *
 * Create new user.
 */
export const usersCreateUserMutation = (options?: Partial<Options<UsersCreateUserData>>): UseMutationOptions<UsersCreateUserResponse, AxiosError<UsersCreateUserError>, Options<UsersCreateUserData>> => {
    const mutationOptions: UseMutationOptions<UsersCreateUserResponse, AxiosError<UsersCreateUserError>, Options<UsersCreateUserData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersCreateUser({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete User Me
 *
 * Delete own user.
 */
export const usersDeleteUserMeMutation = (options?: Partial<Options<UsersDeleteUserMeData>>): UseMutationOptions<UsersDeleteUserMeResponse, AxiosError<DefaultError>, Options<UsersDeleteUserMeData>> => {
    const mutationOptions: UseMutationOptions<UsersDeleteUserMeResponse, AxiosError<DefaultError>, Options<UsersDeleteUserMeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersDeleteUserMe({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersReadUserMeQueryKey = (options?: Options<UsersReadUserMeData>) => createQueryKey('usersReadUserMe', options);

/**
 * Read User Me
 *
 * Get current user.
 */
export const usersReadUserMeOptions = (options?: Options<UsersReadUserMeData>) => queryOptions<UsersReadUserMeResponse, AxiosError<DefaultError>, UsersReadUserMeResponse, ReturnType<typeof usersReadUserMeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await usersReadUserMe({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: usersReadUserMeQueryKey(options)
});

/**
 * Update User Me
 *
 * Update own user.
 */
export const usersUpdateUserMeMutation = (options?: Partial<Options<UsersUpdateUserMeData>>): UseMutationOptions<UsersUpdateUserMeResponse, AxiosError<UsersUpdateUserMeError>, Options<UsersUpdateUserMeData>> => {
    const mutationOptions: UseMutationOptions<UsersUpdateUserMeResponse, AxiosError<UsersUpdateUserMeError>, Options<UsersUpdateUserMeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersUpdateUserMe({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Password Me
 *
 * Update own password.
 */
export const usersUpdatePasswordMeMutation = (options?: Partial<Options<UsersUpdatePasswordMeData>>): UseMutationOptions<UsersUpdatePasswordMeResponse, AxiosError<UsersUpdatePasswordMeError>, Options<UsersUpdatePasswordMeData>> => {
    const mutationOptions: UseMutationOptions<UsersUpdatePasswordMeResponse, AxiosError<UsersUpdatePasswordMeError>, Options<UsersUpdatePasswordMeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersUpdatePasswordMe({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete User
 *
 * Delete a user.
 */
export const usersDeleteUserMutation = (options?: Partial<Options<UsersDeleteUserData>>): UseMutationOptions<UsersDeleteUserResponse, AxiosError<UsersDeleteUserError>, Options<UsersDeleteUserData>> => {
    const mutationOptions: UseMutationOptions<UsersDeleteUserResponse, AxiosError<UsersDeleteUserError>, Options<UsersDeleteUserData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersDeleteUser({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersReadUserByIdQueryKey = (options: Options<UsersReadUserByIdData>) => createQueryKey('usersReadUserById', options);

/**
 * Read User By Id
 *
 * Get a specific user by id.
 */
export const usersReadUserByIdOptions = (options: Options<UsersReadUserByIdData>) => queryOptions<UsersReadUserByIdResponse, AxiosError<UsersReadUserByIdError>, UsersReadUserByIdResponse, ReturnType<typeof usersReadUserByIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await usersReadUserById({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: usersReadUserByIdQueryKey(options)
});

/**
 * Update User
 *
 * Update a user.
 */
export const usersUpdateUserMutation = (options?: Partial<Options<UsersUpdateUserData>>): UseMutationOptions<UsersUpdateUserResponse, AxiosError<UsersUpdateUserError>, Options<UsersUpdateUserData>> => {
    const mutationOptions: UseMutationOptions<UsersUpdateUserResponse, AxiosError<UsersUpdateUserError>, Options<UsersUpdateUserData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersUpdateUser({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const pipelinesReadPipelinesQueryKey = (options?: Options<PipelinesReadPipelinesData>) => createQueryKey('pipelinesReadPipelines', options);

/**
 * Read Pipelines
 *
 * Retrieve pipelines, ordered by last updated. Includes pipeline name.
 */
export const pipelinesReadPipelinesOptions = (options?: Options<PipelinesReadPipelinesData>) => queryOptions<PipelinesReadPipelinesResponse, AxiosError<PipelinesReadPipelinesError>, PipelinesReadPipelinesResponse, ReturnType<typeof pipelinesReadPipelinesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await pipelinesReadPipelines({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: pipelinesReadPipelinesQueryKey(options)
});

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = { ...queryKey[0] };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const pipelinesReadPipelinesInfiniteQueryKey = (options?: Options<PipelinesReadPipelinesData>): QueryKey<Options<PipelinesReadPipelinesData>> => createQueryKey('pipelinesReadPipelines', options, true);

/**
 * Read Pipelines
 *
 * Retrieve pipelines, ordered by last updated. Includes pipeline name.
 */
export const pipelinesReadPipelinesInfiniteOptions = (options?: Options<PipelinesReadPipelinesData>) => infiniteQueryOptions<PipelinesReadPipelinesResponse, AxiosError<PipelinesReadPipelinesError>, InfiniteData<PipelinesReadPipelinesResponse>, QueryKey<Options<PipelinesReadPipelinesData>>, number | Pick<QueryKey<Options<PipelinesReadPipelinesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<PipelinesReadPipelinesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await pipelinesReadPipelines({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: pipelinesReadPipelinesInfiniteQueryKey(options)
});

/**
 * Create Pipeline
 *
 * Create new pipeline.
 */
export const pipelinesCreatePipelineMutation = (options?: Partial<Options<PipelinesCreatePipelineData>>): UseMutationOptions<PipelinesCreatePipelineResponse, AxiosError<PipelinesCreatePipelineError>, Options<PipelinesCreatePipelineData>> => {
    const mutationOptions: UseMutationOptions<PipelinesCreatePipelineResponse, AxiosError<PipelinesCreatePipelineError>, Options<PipelinesCreatePipelineData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await pipelinesCreatePipeline({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Pipeline
 *
 * Delete an pipeline.
 */
export const pipelinesDeletePipelineMutation = (options?: Partial<Options<PipelinesDeletePipelineData>>): UseMutationOptions<PipelinesDeletePipelineResponse, AxiosError<PipelinesDeletePipelineError>, Options<PipelinesDeletePipelineData>> => {
    const mutationOptions: UseMutationOptions<PipelinesDeletePipelineResponse, AxiosError<PipelinesDeletePipelineError>, Options<PipelinesDeletePipelineData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await pipelinesDeletePipeline({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const pipelinesReadPipelineQueryKey = (options: Options<PipelinesReadPipelineData>) => createQueryKey('pipelinesReadPipeline', options);

/**
 * Read Pipeline
 *
 * Get pipeline by ID.
 */
export const pipelinesReadPipelineOptions = (options: Options<PipelinesReadPipelineData>) => queryOptions<PipelinesReadPipelineResponse, AxiosError<PipelinesReadPipelineError>, PipelinesReadPipelineResponse, ReturnType<typeof pipelinesReadPipelineQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await pipelinesReadPipeline({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: pipelinesReadPipelineQueryKey(options)
});

/**
 * Update Pipeline
 *
 * Update a pipeline's name.
 */
export const pipelinesUpdatePipelineMutation = (options?: Partial<Options<PipelinesUpdatePipelineData>>): UseMutationOptions<PipelinesUpdatePipelineResponse, AxiosError<PipelinesUpdatePipelineError>, Options<PipelinesUpdatePipelineData>> => {
    const mutationOptions: UseMutationOptions<PipelinesUpdatePipelineResponse, AxiosError<PipelinesUpdatePipelineError>, Options<PipelinesUpdatePipelineData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await pipelinesUpdatePipeline({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const pipelinesListPipelineRevisionsQueryKey = (options: Options<PipelinesListPipelineRevisionsData>) => createQueryKey('pipelinesListPipelineRevisions', options);

/**
 * List Pipeline Revisions
 *
 * List revisions for a pipeline (paginated).
 */
export const pipelinesListPipelineRevisionsOptions = (options: Options<PipelinesListPipelineRevisionsData>) => queryOptions<PipelinesListPipelineRevisionsResponse, AxiosError<PipelinesListPipelineRevisionsError>, PipelinesListPipelineRevisionsResponse, ReturnType<typeof pipelinesListPipelineRevisionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await pipelinesListPipelineRevisions({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: pipelinesListPipelineRevisionsQueryKey(options)
});

export const pipelinesListPipelineRevisionsInfiniteQueryKey = (options: Options<PipelinesListPipelineRevisionsData>): QueryKey<Options<PipelinesListPipelineRevisionsData>> => createQueryKey('pipelinesListPipelineRevisions', options, true);

/**
 * List Pipeline Revisions
 *
 * List revisions for a pipeline (paginated).
 */
export const pipelinesListPipelineRevisionsInfiniteOptions = (options: Options<PipelinesListPipelineRevisionsData>) => infiniteQueryOptions<PipelinesListPipelineRevisionsResponse, AxiosError<PipelinesListPipelineRevisionsError>, InfiniteData<PipelinesListPipelineRevisionsResponse>, QueryKey<Options<PipelinesListPipelineRevisionsData>>, number | Pick<QueryKey<Options<PipelinesListPipelineRevisionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<PipelinesListPipelineRevisionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await pipelinesListPipelineRevisions({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: pipelinesListPipelineRevisionsInfiniteQueryKey(options)
});

/**
 * Add Pipeline Revision
 *
 * Add a new revision to a pipeline.
 */
export const pipelinesAddPipelineRevisionMutation = (options?: Partial<Options<PipelinesAddPipelineRevisionData>>): UseMutationOptions<PipelinesAddPipelineRevisionResponse, AxiosError<PipelinesAddPipelineRevisionError>, Options<PipelinesAddPipelineRevisionData>> => {
    const mutationOptions: UseMutationOptions<PipelinesAddPipelineRevisionResponse, AxiosError<PipelinesAddPipelineRevisionError>, Options<PipelinesAddPipelineRevisionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await pipelinesAddPipelineRevision({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const pipelinesReadPipelineRevisionQueryKey = (options: Options<PipelinesReadPipelineRevisionData>) => createQueryKey('pipelinesReadPipelineRevision', options);

/**
 * Read Pipeline Revision
 *
 * Get specific revision data for a pipeline.
 */
export const pipelinesReadPipelineRevisionOptions = (options: Options<PipelinesReadPipelineRevisionData>) => queryOptions<PipelinesReadPipelineRevisionResponse, AxiosError<PipelinesReadPipelineRevisionError>, PipelinesReadPipelineRevisionResponse, ReturnType<typeof pipelinesReadPipelineRevisionQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await pipelinesReadPipelineRevision({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: pipelinesReadPipelineRevisionQueryKey(options)
});

/**
 * Update Pipeline Revision
 *
 * Update a specific pipeline revision.
 */
export const pipelinesUpdatePipelineRevisionMutation = (options?: Partial<Options<PipelinesUpdatePipelineRevisionData>>): UseMutationOptions<PipelinesUpdatePipelineRevisionResponse, AxiosError<PipelinesUpdatePipelineRevisionError>, Options<PipelinesUpdatePipelineRevisionData>> => {
    const mutationOptions: UseMutationOptions<PipelinesUpdatePipelineRevisionResponse, AxiosError<PipelinesUpdatePipelineRevisionError>, Options<PipelinesUpdatePipelineRevisionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await pipelinesUpdatePipelineRevision({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Pipeline Revision Positions
 *
 * Update operator positions for a specific pipeline revision.
 */
export const pipelinesUpdatePipelineRevisionPositionsMutation = (options?: Partial<Options<PipelinesUpdatePipelineRevisionPositionsData>>): UseMutationOptions<PipelinesUpdatePipelineRevisionPositionsResponse, AxiosError<PipelinesUpdatePipelineRevisionPositionsError>, Options<PipelinesUpdatePipelineRevisionPositionsData>> => {
    const mutationOptions: UseMutationOptions<PipelinesUpdatePipelineRevisionPositionsResponse, AxiosError<PipelinesUpdatePipelineRevisionPositionsError>, Options<PipelinesUpdatePipelineRevisionPositionsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await pipelinesUpdatePipelineRevisionPositions({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Duplicate Pipeline
 *
 * Duplicate a pipeline with all its revisions.
 */
export const pipelinesDuplicatePipelineMutation = (options?: Partial<Options<PipelinesDuplicatePipelineData>>): UseMutationOptions<PipelinesDuplicatePipelineResponse, AxiosError<PipelinesDuplicatePipelineError>, Options<PipelinesDuplicatePipelineData>> => {
    const mutationOptions: UseMutationOptions<PipelinesDuplicatePipelineResponse, AxiosError<PipelinesDuplicatePipelineError>, Options<PipelinesDuplicatePipelineData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await pipelinesDuplicatePipeline({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const pipelinesListPipelineDeploymentsQueryKey = (options: Options<PipelinesListPipelineDeploymentsData>) => createQueryKey('pipelinesListPipelineDeployments', options);

/**
 * List Pipeline Deployments
 *
 * List deployments for a pipeline.
 */
export const pipelinesListPipelineDeploymentsOptions = (options: Options<PipelinesListPipelineDeploymentsData>) => queryOptions<PipelinesListPipelineDeploymentsResponse, AxiosError<PipelinesListPipelineDeploymentsError>, PipelinesListPipelineDeploymentsResponse, ReturnType<typeof pipelinesListPipelineDeploymentsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await pipelinesListPipelineDeployments({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: pipelinesListPipelineDeploymentsQueryKey(options)
});

export const pipelinesListPipelineDeploymentsInfiniteQueryKey = (options: Options<PipelinesListPipelineDeploymentsData>): QueryKey<Options<PipelinesListPipelineDeploymentsData>> => createQueryKey('pipelinesListPipelineDeployments', options, true);

/**
 * List Pipeline Deployments
 *
 * List deployments for a pipeline.
 */
export const pipelinesListPipelineDeploymentsInfiniteOptions = (options: Options<PipelinesListPipelineDeploymentsData>) => infiniteQueryOptions<PipelinesListPipelineDeploymentsResponse, AxiosError<PipelinesListPipelineDeploymentsError>, InfiniteData<PipelinesListPipelineDeploymentsResponse>, QueryKey<Options<PipelinesListPipelineDeploymentsData>>, number | Pick<QueryKey<Options<PipelinesListPipelineDeploymentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<PipelinesListPipelineDeploymentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await pipelinesListPipelineDeployments({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: pipelinesListPipelineDeploymentsInfiniteQueryKey(options)
});

export const pipelinesListPipelineRevisionDeploymentsQueryKey = (options: Options<PipelinesListPipelineRevisionDeploymentsData>) => createQueryKey('pipelinesListPipelineRevisionDeployments', options);

/**
 * List Pipeline Revision Deployments
 *
 * List all deployments for a specific pipeline revision.
 */
export const pipelinesListPipelineRevisionDeploymentsOptions = (options: Options<PipelinesListPipelineRevisionDeploymentsData>) => queryOptions<PipelinesListPipelineRevisionDeploymentsResponse, AxiosError<PipelinesListPipelineRevisionDeploymentsError>, PipelinesListPipelineRevisionDeploymentsResponse, ReturnType<typeof pipelinesListPipelineRevisionDeploymentsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await pipelinesListPipelineRevisionDeployments({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: pipelinesListPipelineRevisionDeploymentsQueryKey(options)
});

export const pipelinesListPipelineRevisionDeploymentsInfiniteQueryKey = (options: Options<PipelinesListPipelineRevisionDeploymentsData>): QueryKey<Options<PipelinesListPipelineRevisionDeploymentsData>> => createQueryKey('pipelinesListPipelineRevisionDeployments', options, true);

/**
 * List Pipeline Revision Deployments
 *
 * List all deployments for a specific pipeline revision.
 */
export const pipelinesListPipelineRevisionDeploymentsInfiniteOptions = (options: Options<PipelinesListPipelineRevisionDeploymentsData>) => infiniteQueryOptions<PipelinesListPipelineRevisionDeploymentsResponse, AxiosError<PipelinesListPipelineRevisionDeploymentsError>, InfiniteData<PipelinesListPipelineRevisionDeploymentsResponse>, QueryKey<Options<PipelinesListPipelineRevisionDeploymentsData>>, number | Pick<QueryKey<Options<PipelinesListPipelineRevisionDeploymentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<PipelinesListPipelineRevisionDeploymentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await pipelinesListPipelineRevisionDeployments({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: pipelinesListPipelineRevisionDeploymentsInfiniteQueryKey(options)
});

export const deploymentsListPipelineDeploymentsQueryKey = (options?: Options<DeploymentsListPipelineDeploymentsData>) => createQueryKey('deploymentsListPipelineDeployments', options);

/**
 * List Pipeline Deployments
 *
 * Get all pipeline deployments accessible to the current user with pagination.
 * Optionally filter by state.
 */
export const deploymentsListPipelineDeploymentsOptions = (options?: Options<DeploymentsListPipelineDeploymentsData>) => queryOptions<DeploymentsListPipelineDeploymentsResponse, AxiosError<DeploymentsListPipelineDeploymentsError>, DeploymentsListPipelineDeploymentsResponse, ReturnType<typeof deploymentsListPipelineDeploymentsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await deploymentsListPipelineDeployments({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: deploymentsListPipelineDeploymentsQueryKey(options)
});

export const deploymentsListPipelineDeploymentsInfiniteQueryKey = (options?: Options<DeploymentsListPipelineDeploymentsData>): QueryKey<Options<DeploymentsListPipelineDeploymentsData>> => createQueryKey('deploymentsListPipelineDeployments', options, true);

/**
 * List Pipeline Deployments
 *
 * Get all pipeline deployments accessible to the current user with pagination.
 * Optionally filter by state.
 */
export const deploymentsListPipelineDeploymentsInfiniteOptions = (options?: Options<DeploymentsListPipelineDeploymentsData>) => infiniteQueryOptions<DeploymentsListPipelineDeploymentsResponse, AxiosError<DeploymentsListPipelineDeploymentsError>, InfiniteData<DeploymentsListPipelineDeploymentsResponse>, QueryKey<Options<DeploymentsListPipelineDeploymentsData>>, number | Pick<QueryKey<Options<DeploymentsListPipelineDeploymentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<DeploymentsListPipelineDeploymentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await deploymentsListPipelineDeployments({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: deploymentsListPipelineDeploymentsInfiniteQueryKey(options)
});

/**
 * Create Pipeline Deployment
 *
 * Create a new pipeline deployment and publish initialization event.
 * State transitions are managed by the orchestrator.
 */
export const deploymentsCreatePipelineDeploymentMutation = (options?: Partial<Options<DeploymentsCreatePipelineDeploymentData>>): UseMutationOptions<DeploymentsCreatePipelineDeploymentResponse, AxiosError<DeploymentsCreatePipelineDeploymentError>, Options<DeploymentsCreatePipelineDeploymentData>> => {
    const mutationOptions: UseMutationOptions<DeploymentsCreatePipelineDeploymentResponse, AxiosError<DeploymentsCreatePipelineDeploymentError>, Options<DeploymentsCreatePipelineDeploymentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deploymentsCreatePipelineDeployment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deploymentsReadPipelineDeploymentQueryKey = (options: Options<DeploymentsReadPipelineDeploymentData>) => createQueryKey('deploymentsReadPipelineDeployment', options);

/**
 * Read Pipeline Deployment
 *
 * Get pipeline deployment by ID.
 */
export const deploymentsReadPipelineDeploymentOptions = (options: Options<DeploymentsReadPipelineDeploymentData>) => queryOptions<DeploymentsReadPipelineDeploymentResponse, AxiosError<DeploymentsReadPipelineDeploymentError>, DeploymentsReadPipelineDeploymentResponse, ReturnType<typeof deploymentsReadPipelineDeploymentQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await deploymentsReadPipelineDeployment({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: deploymentsReadPipelineDeploymentQueryKey(options)
});

/**
 * Update Pipeline Deployment
 *
 * Update a pipeline deployment state and publish events for the orchestrator.
 */
export const deploymentsUpdatePipelineDeploymentMutation = (options?: Partial<Options<DeploymentsUpdatePipelineDeploymentData>>): UseMutationOptions<DeploymentsUpdatePipelineDeploymentResponse, AxiosError<DeploymentsUpdatePipelineDeploymentError>, Options<DeploymentsUpdatePipelineDeploymentData>> => {
    const mutationOptions: UseMutationOptions<DeploymentsUpdatePipelineDeploymentResponse, AxiosError<DeploymentsUpdatePipelineDeploymentError>, Options<DeploymentsUpdatePipelineDeploymentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deploymentsUpdatePipelineDeployment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Operator Event
 *
 * Publish an operator event for the specified deployment and operator.
 */
export const deploymentsCreateOperatorEventMutation = (options?: Partial<Options<DeploymentsCreateOperatorEventData>>): UseMutationOptions<DeploymentsCreateOperatorEventResponse, AxiosError<DeploymentsCreateOperatorEventError>, Options<DeploymentsCreateOperatorEventData>> => {
    const mutationOptions: UseMutationOptions<DeploymentsCreateOperatorEventResponse, AxiosError<DeploymentsCreateOperatorEventError>, Options<DeploymentsCreateOperatorEventData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deploymentsCreateOperatorEvent({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const operatorsReadOperatorsQueryKey = (options?: Options<OperatorsReadOperatorsData>) => createQueryKey('operatorsReadOperators', options);

/**
 * Read Operators
 *
 * Retrieve available operators. Use refresh=true to invalidate cache and fetch fresh data.
 */
export const operatorsReadOperatorsOptions = (options?: Options<OperatorsReadOperatorsData>) => queryOptions<OperatorsReadOperatorsResponse, AxiosError<OperatorsReadOperatorsError>, OperatorsReadOperatorsResponse, ReturnType<typeof operatorsReadOperatorsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await operatorsReadOperators({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: operatorsReadOperatorsQueryKey(options)
});

/**
 * Launch Agent
 *
 * Launch an agent remotely.
 */
export const agentsLaunchAgentMutation = (options?: Partial<Options<AgentsLaunchAgentData>>): UseMutationOptions<unknown, AxiosError<AgentsLaunchAgentError>, Options<AgentsLaunchAgentData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<AgentsLaunchAgentError>, Options<AgentsLaunchAgentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await agentsLaunchAgent({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};
